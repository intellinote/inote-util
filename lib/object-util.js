// Generated by CoffeeScript 1.12.6
(function() {
  var ObjectUtil,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  ObjectUtil = (function() {
    function ObjectUtil() {}

    ObjectUtil.deep_equals = function(a, b) {
      return ObjectUtil.deep_equal(a, b);
    };

    ObjectUtil.deep_equal = function(a, b) {
      var checked, elt, i, j, len, n, v;
      if ((a == null) && (b == null)) {
        return true;
      } else if ((a != null) !== (b != null)) {
        return false;
      } else if (Array.isArray(a) !== Array.isArray(b)) {
        return false;
      } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return false;
        } else {
          for (i = j = 0, len = a.length; j < len; i = ++j) {
            elt = a[i];
            if (!ObjectUtil.deep_equal(elt, b[i])) {
              return false;
            }
          }
          return true;
        }
      } else if (ObjectUtil.is_true_object(a) !== ObjectUtil.is_true_object(b)) {
        return false;
      } else if (ObjectUtil.is_true_object(a) && ObjectUtil.is_true_object(b)) {
        checked = [];
        for (n in a) {
          v = a[n];
          if (!ObjectUtil.deep_equal(v, b[n])) {
            return false;
          } else {
            checked.push(n);
          }
        }
        for (n in b) {
          v = b[n];
          if (indexOf.call(checked, n) < 0) {
            if (!ObjectUtil.deep_equal(v, a[n])) {
              return false;
            }
          }
        }
        return true;
      } else {
        return a === b;
      }
    };

    ObjectUtil.__JSON_DIFF_ADD = "a";

    ObjectUtil.__JSON_DIFF_REM = "d";

    ObjectUtil.__JSON_DIFF_CHG = "c";

    ObjectUtil.__JSON_DIFF_NIL = void 0;

    ObjectUtil.is_true_object = function(obj) {
      return (obj != null) && (typeof obj === 'object') && (!Array.isArray(obj));
    };

    ObjectUtil.__diff_non_objects = function(old_val, new_val) {
      if ((old_val != null) && (new_val == null)) {
        return ObjectUtil.__JSON_DIFF_REM;
      } else if ((new_val != null) && (old_val == null)) {
        return ObjectUtil.__JSON_DIFF_ADD;
      } else if ((new_val == null) && (old_val == null)) {
        return ObjectUtil.__JSON_DIFF_NIL;
      } else if (Array.isArray(old_val) && Array.isArray(new_val)) {
        if (ObjectUtil.deep_equal(old_val, new_val)) {
          return ObjectUtil.__JSON_DIFF_NIL;
        } else {
          return ObjectUtil.__JSON_DIFF_CHG;
        }
      } else if (Array.isArray(old_val) !== Array.isArray(new_val)) {
        return ObjectUtil.__JSON_DIFF_CHG;
      } else if ((typeof old_val) !== (typeof new_val)) {
        return ObjectUtil.__JSON_DIFF_CHG;
      } else if (old_val !== new_val) {
        return ObjectUtil.__JSON_DIFF_CHG;
      } else {
        return ObjectUtil.__JSON_DIFF_NIL;
      }
    };

    ObjectUtil.__diff_objects = function(old_map, new_map) {
      var check_fn, checked, delta, name, new_val, old_val;
      delta = null;
      check_fn = function(name, val_a, val_b) {
        var child;
        if (ObjectUtil.is_true_object(val_a) && ObjectUtil.is_true_object(val_b)) {
          child = ObjectUtil.__diff_objects(val_a, val_b);
          if (child != null) {
            if (delta == null) {
              delta = {};
            }
            return delta[name] = child;
          }
        } else {
          child = ObjectUtil.__diff_non_objects(val_a, val_b);
          if (child != null) {
            if (delta == null) {
              delta = {};
            }
            return delta[name] = child;
          }
        }
      };
      checked = [];
      for (name in old_map) {
        old_val = old_map[name];
        new_val = new_map[name];
        check_fn(name, old_val, new_val);
        checked.push(name);
      }
      for (name in new_map) {
        new_val = new_map[name];
        if (indexOf.call(checked, name) < 0) {
          old_val = old_map[name];
          check_fn(name, old_val, new_val);
        }
      }
      return delta;
    };

    ObjectUtil.json_diff = function(old_map, new_map) {
      return ObjectUtil.diff_json(old_map, new_map);
    };

    ObjectUtil.diff_json = function(old_map, new_map) {
      if (ObjectUtil.is_true_object(old_map) && ObjectUtil.is_true_object(new_map)) {
        return ObjectUtil.__diff_objects(old_map, new_map);
      } else {
        return ObjectUtil.__diff_non_objects(old_map, new_map);
      }
    };

    ObjectUtil.flatten_map = function(map, delim) {
      if (delim == null) {
        delim = ".";
      }
      return ObjectUtil._flatten_map([], {}, map, delim);
    };

    ObjectUtil._flatten_map = function(ancestory, flat, map, delim) {
      var n, new_ancestory, v;
      if (delim == null) {
        delim = ".";
      }
      for (n in map) {
        v = map[n];
        new_ancestory = ancestory.slice(0);
        new_ancestory.push(n);
        if ((v != null) && typeof v === 'object' && !Array.isArray(v)) {
          flat = ObjectUtil._flatten_map(new_ancestory, flat, v, delim);
        } else {
          flat[new_ancestory.join(delim)] = v;
        }
      }
      return flat;
    };

    ObjectUtil.remove_null = function(map) {
      var elt, j, len, n, new_array, new_map, v;
      if (map == null) {
        return null;
      } else if (Array.isArray(map)) {
        new_array = [];
        for (j = 0, len = map.length; j < len; j++) {
          elt = map[j];
          if (elt != null) {
            new_array.push(elt);
          }
        }
        return new_array;
      } else if (typeof map === 'object') {
        new_map = {};
        for (n in map) {
          v = map[n];
          if (v != null) {
            new_map[n] = v;
          }
        }
        return new_map;
      } else {
        return map;
      }
    };

    ObjectUtil.remove_falsey = function(map) {
      var elt, j, len, n, new_array, new_map, v;
      if (map == null) {
        return map;
      } else if (Array.isArray(map)) {
        new_array = [];
        for (j = 0, len = map.length; j < len; j++) {
          elt = map[j];
          if (elt) {
            new_array.push(elt);
          }
        }
        return new_array;
      } else if (typeof map === 'object') {
        new_map = {};
        for (n in map) {
          v = map[n];
          if (v) {
            new_map[n] = v;
          }
        }
        return new_map;
      } else if (!map) {
        return null;
      } else {
        return map;
      }
    };

    ObjectUtil.merge = function() {
      var args, j, len, m, map, n, ref, ref1, v;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      map = {};
      if (args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      ref = args != null ? args : [];
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        ref1 = m != null ? m : {};
        for (n in ref1) {
          v = ref1[n];
          map[n] = v;
        }
      }
      return map;
    };

    ObjectUtil.deep_merge = function() {
      var args, j, len, m, map, n, ref, ref1, v;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      map = {};
      if (args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
      }
      ref = args != null ? args : [];
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        ref1 = m != null ? m : {};
        for (n in ref1) {
          v = ref1[n];
          if ((v != null) && (typeof v === 'object') && (!Array.isArray(v))) {
            if (!((map[n] != null) && (typeof map[n] === 'object') && (!Array.isArray(v)))) {
              map[n] = ObjectUtil.shallow_clone(v);
            } else {
              map[n] = ObjectUtil.deep_merge(map[n], v);
            }
          } else {
            map[n] = v;
          }
        }
      }
      return map;
    };

    ObjectUtil.shallow_clone = function(map) {
      var k, new_array, new_map, ref, v;
      if (map == null) {
        return null;
      } else if (Array.isArray(map)) {
        new_array = [];
        new_array = new_array.concat(map);
        return new_array;
      } else if (typeof map === 'string') {
        return new String(map);
      } else if ((ref = typeof map) === 'number' || ref === 'boolean') {
        return map;
      } else {
        new_map = {};
        for (k in map) {
          v = map[k];
          new_map[k] = v;
        }
        return new_map;
      }
    };

    ObjectUtil.deep_clone = function(map) {
      var elt, j, k, len, new_array, new_map, ref, v;
      if (map == null) {
        return null;
      } else if (Array.isArray(map)) {
        new_array = [];
        for (j = 0, len = map.length; j < len; j++) {
          elt = map[j];
          new_array.push(ObjectUtil.deep_clone(elt));
        }
        return new_array;
      } else if ((ref = typeof map) === 'string' || ref === 'number' || ref === 'boolean') {
        return ObjectUtil.shallow_clone(map);
      } else {
        new_map = {};
        for (k in map) {
          v = map[k];
          new_map[k] = ObjectUtil.deep_clone(v);
        }
        return new_map;
      }
    };

    ObjectUtil.object_array_to_map = function(array, key_field, options) {
      var duplicates, elt, j, key, len, map, ref, ref1, xform;
      if (options == null) {
        options = {};
      }
      xform = (ref = options != null ? options.transform : void 0) != null ? ref : (function(x) {
        return x;
      });
      duplicates = (ref1 = options != null ? options.duplicates : void 0) != null ? ref1 : "overwrite";
      if (duplicates !== "overwrite" && duplicates !== "stack" && duplicates !== "merge" && duplicates !== "skip") {
        throw new Error("Unrecognized value for duplicates option. Found \"" + duplicates + "\". Expected \"overwrite\", \"stack\", \"skip\", \"merge\" or null.");
      }
      map = {};
      for (j = 0, len = array.length; j < len; j++) {
        elt = array[j];
        key = xform(elt[key_field]);
        if ((map[key] != null) && duplicates !== "overwrite") {
          if (duplicates === 'stack') {
            if (Array.isArray(map[key])) {
              map[key].push(elt);
            } else {
              map[key] = [map[key], elt];
            }
          } else if (duplicates === 'merge') {
            map[key] = ObjectUtil.merge(map[key], elt);
          }
        } else {
          map[key] = elt;
        }
      }
      return map;
    };

    return ObjectUtil;

  })();

  exports.ObjectUtil = exports.MapUtil = ObjectUtil;

}).call(this);
