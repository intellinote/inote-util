// Generated by CoffeeScript 1.12.6
(function() {
  var DATA, DEBUG, FileUtil, HOMEDIR, LIB_COV, LIB_DIR, Util, fs, magic, mkdirp, mmmagic, path, ref, remove,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  DATA = path.join(HOMEDIR, "data");

  Util = require(path.join(LIB_DIR, 'util')).Util;

  mkdirp = require('mkdirp');

  remove = require('remove');

  DEBUG = /(^|,)file-?util($|,)/i.test(typeof process !== "undefined" && process !== null ? (ref = process.env) != null ? ref.NODE_DEBUG : void 0 : void 0);

  mmmagic = require('mmmagic');

  magic = new mmmagic.Magic(mmmagic.MAGIC_MIME_TYPE);

  FileUtil = (function() {
    function FileUtil() {}

    FileUtil.is_file = function(file, callback) {
      return fs.stat(file, function(err, stat) {
        var ref1;
        if ((err != null) && err.code === 'ENOENT') {
          return callback(null, false);
        } else {
          return callback(err, (ref1 = stat != null ? typeof stat.isFile === "function" ? stat.isFile() : void 0 : void 0) != null ? ref1 : false);
        }
      });
    };

    FileUtil.is_dir = function(file, callback) {
      return fs.stat(file, function(err, stat) {
        var ref1;
        if ((err != null) && err.code === 'ENOENT') {
          return callback(null, false);
        } else {
          return callback(err, (ref1 = stat != null ? typeof stat.isDirectory === "function" ? stat.isDirectory() : void 0 : void 0) != null ? ref1 : false);
        }
      });
    };

    FileUtil.is_directory = function(file, callback) {
      return FileUtil.is_dir(file, callback);
    };

    FileUtil._file_matches = function(dir, file, pattern, types, callback) {
      var full_path;
      if (typeof pattern === 'function' && (types == null) && (callback == null)) {
        callback = pattern;
        pattern = null;
      } else if (typeof types === 'function' && (callback == null)) {
        callback = types;
        types = null;
      }
      if ((types != null) && typeof types === 'string') {
        types = [types];
      }
      if ((pattern != null) && !pattern.test(file)) {
        return callback(null, false);
      } else if (types != null) {
        full_path = path.join(dir, file);
        return fs.stat(full_path, function(err, stat) {
          if ((err != null) && err.code === 'ENOENT') {
            return callback(null, false);
          } else if (err != null) {
            return callback(err);
          } else {
            if (stat.isFile() && (indexOf.call(types, "file") >= 0)) {
              return callback(null, true);
            } else if (stat.isDirectory() && ((indexOf.call(types, "dir") >= 0) || (indexOf.call(types, "directory") >= 0))) {
              return callback(null, true);
            } else {
              return callback(null, false);
            }
          }
        });
      } else {
        return callback(null, true);
      }
    };

    FileUtil.ls = function(dir, options, callback) {
      var pattern, recurse, ref1, ref2, types;
      if (typeof options === 'function' && (callback == null)) {
        callback = options;
        options = null;
      }
      if (options == null) {
        options = {};
      }
      recurse = Util.truthy_string((ref1 = options.recurse) != null ? ref1 : false);
      pattern = options.pattern;
      types = (ref2 = options.types) != null ? ref2 : options.type;
      return fs.readdir(dir, function(err, files) {
        var action, found;
        if ((err != null) || (files == null)) {
          return callback(null, null);
        } else {
          found = [];
          action = function(file, index, list, next) {
            return FileUtil._file_matches(dir, file, pattern, types, function(err, matched) {
              if (err != null) {
                return callback(err);
              } else if (matched) {
                found.push(path.join(dir, file));
                return next();
              } else {
                return next();
              }
            });
          };
          return Util.for_each_async(files, action, function() {
            if (!recurse) {
              return callback(null, found);
            } else {
              action = function(file, index, list, next) {
                var full_file;
                full_file = path.join(dir, file);
                return FileUtil.is_dir(full_file, function(err, is_dir) {
                  if (err != null) {
                    return callback(err);
                  } else {
                    if (is_dir) {
                      return FileUtil.ls(full_file, options, function(err, files_in_dir) {
                        if (err != null) {
                          return callback(err);
                        } else {
                          if (files_in_dir != null) {
                            found = found.concat(files_in_dir);
                          }
                          return next();
                        }
                      });
                    } else {
                      return next();
                    }
                  }
                });
              };
              return Util.for_each_async(files, action, function() {
                return callback(null, found);
              });
            }
          });
        }
      });
    };

    FileUtil.sanitize_filename = function(str) {
      var BAD_CHARS, MAX_BASENAME, MAX_EXTENSION, SUBST_CHAR, base, ext, parent, ref1, ref2, ref3;
      BAD_CHARS = /[^-A-Za-z0-9_]/g;
      SUBST_CHAR = '-';
      MAX_EXTENSION = 260;
      MAX_BASENAME = 260;
      parent = (ref1 = path.dirname(str)) != null ? ref1 : '';
      ext = (ref2 = path.extname(str)) != null ? ref2 : '';
      base = (ref3 = path.basename(str, ext)) != null ? ref3 : '';
      if (/^\..+/.test(ext)) {
        ext = "." + ext.substring(1).replace(BAD_CHARS, SUBST_CHAR);
      }
      if ((ext != null ? ext.length : void 0) > MAX_EXTENSION) {
        ext = ext.substring(0, MAX_EXTENSION);
      }
      base = base.replace(BAD_CHARS, SUBST_CHAR);
      if ((base != null ? base.length : void 0) > MAX_BASENAME) {
        base = base.substring(0, MAX_BASENAME);
      }
      if ((parent != null ? parent.length : void 0) > 0) {
        return path.join(parent, "" + base + ext);
      } else {
        return "" + base + ext;
      }
    };

    FileUtil.uniquify_filename = function(dir, basename, ext, minpadwidth, maxpadwidth) {
      var i, max_attempts;
      if (ext == null) {
        ext = '';
      }
      if (minpadwidth == null) {
        minpadwidth = 3;
      }
      if (maxpadwidth == null) {
        maxpadwidth = 5;
      }
      max_attempts = Math.pow(10, maxpadwidth);
      if (!fs.existsSync(path.join(dir, "" + basename + ext))) {
        return "" + basename + ext;
      } else {
        i = 1;
        while (fs.existsSync(path.join(dir, basename + "-" + (Util.lpad(i, minpadwidth, '0')) + ext))) {
          if (i > max_attempts) {
            throw new Error("Unable to obtain a unique filename for \"" + basename + ext + "\" in \"" + dir + "\" after " + max_attempts + " attempts.");
          } else {
            i += 1;
          }
        }
        return basename + "-" + (Util.lpad(i, minpadwidth, '0')) + ext;
      }
    };

    FileUtil.mkdir = function(dir) {
      var e;
      if (dir != null) {
        try {
          mkdirp.sync(dir);
          return true;
        } catch (error) {
          e = error;
          if (DEBUG) {
            console.error("FileUtil.mkdir", e);
          }
          return false;
        }
      } else {
        return false;
      }
    };

    FileUtil.rm = function() {
      var e, file, files, j, len, result;
      files = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = false;
      if ((files != null) && files.length > 0) {
        result = true;
        for (j = 0, len = files.length; j < len; j++) {
          file = files[j];
          try {
            fs.unlinkSync(file);
          } catch (error) {
            e = error;
            result = false;
            if (DEBUG) {
              console.error("FileUtil.rm", e);
            }
          }
        }
      }
      return result;
    };

    FileUtil.rmdir = function() {
      var dir, dirs, e, j, len, result;
      dirs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      result = false;
      if ((dirs != null) && dirs.length > 0) {
        result = true;
        for (j = 0, len = dirs.length; j < len; j++) {
          dir = dirs[j];
          try {
            remove.removeSync(dir);
          } catch (error) {
            e = error;
            result = false;
            if (DEBUG) {
              console.error("FileUtil.rmdir", e);
            }
          }
        }
      }
      return result;
    };

    FileUtil.read_stdin_sync = function(end_byte, buffer_size) {
      var all_buf, all_bytes_read, b, bytes_read, end_byte_read, err, fd, j, len, read_buf, ref1, temp_buf;
      if (end_byte == null) {
        end_byte = "\x04";
      }
      if (buffer_size == null) {
        buffer_size = 512;
      }
      read_buf = new Buffer(buffer_size);
      bytes_read = 0;
      all_buf = new Buffer(buffer_size);
      all_bytes_read = 0;
      end_byte_read = false;
      fd = typeof process !== "undefined" && process !== null ? (ref1 = process.stdin) != null ? ref1.fd : void 0 : void 0;
      if (fd == null) {
        throw new Error("Unable to obtain stdin.fd");
      } else {
        while (true) {
          try {
            bytes_read = fs.readSync(fd, read_buf, 0, buffer_size, null);
            temp_buf = new Buffer(all_bytes_read + bytes_read);
            all_buf.copy(temp_buf, 0, 0, all_bytes_read);
            read_buf.copy(temp_buf, all_bytes_read, 0, bytes_read);
            all_buf = temp_buf;
            all_bytes_read += bytes_read;
            for (j = 0, len = bytes_read.length; j < len; j++) {
              b = bytes_read[j];
              if (b === end_byte) {
                end_byte_read = true;
                break;
              }
            }
            if (end_byte_read) {
              break;
            }
          } catch (error) {
            err = error;
            if (err.code === 'EOF') {
              break;
            } else {
              throw err;
            }
          }
          if (bytes_read === 0) {
            break;
          }
        }
        return all_buf;
      }
    };

    FileUtil.load_json_file_sync = function(file, ignore_errors) {
      var err;
      if (ignore_errors == null) {
        ignore_errors = false;
      }
      try {
        return JSON.parse(fs.readFileSync(file).toString());
      } catch (error) {
        err = error;
        if (ignore_errors) {
          return null;
        } else {
          throw err;
        }
      }
    };

    FileUtil.load_json_stdin_sync = function(end_byte, buffer_size, ignore_errors) {
      var err;
      if (end_byte == null) {
        end_byte = "\x04";
      }
      if (buffer_size == null) {
        buffer_size = 512;
      }
      if (ignore_errors == null) {
        ignore_errors = false;
      }
      try {
        return JSON.parse(FileUtil.read_stdin_sync(end_byte, buffer_size));
      } catch (error) {
        err = error;
        if (ignore_errors) {
          return null;
        } else {
          throw err;
        }
      }
    };

    FileUtil.touch = function(file, callback) {
      return fs.open(file, "wx", function(err, fd) {
        if (fd != null) {
          return fs.close(fd, function(err) {
            return typeof callback === "function" ? callback() : void 0;
          });
        } else {
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    };

    FileUtil.copy_file = function(src, dest, callback) {
      var callback_called, done, input, output;
      callback_called = false;
      done = function(err) {
        if (!callback_called) {
          callback_called = true;
          return callback(err);
        }
      };
      input = fs.createReadStream(src);
      input.on("error", function(err) {
        return done(err);
      });
      output = fs.createWriteStream(dest);
      output.on("error", function(err) {
        return done(err);
      });
      output.once("close", function() {
        return done();
      });
      return input.pipe(output);
    };

    FileUtil.move_file = function(src, dest, callback) {
      var callback_called, done, input, output;
      callback_called = false;
      done = function(err) {
        if (!callback_called) {
          callback_called = true;
          return callback(err);
        }
      };
      input = fs.createReadStream(src);
      input.on("error", function(err) {
        return done(err);
      });
      output = fs.createWriteStream(dest);
      output.on("error", function(err) {
        return done(err);
      });
      output.once("close", function() {
        FileUtil.rm(src);
        return done();
      });
      return input.pipe(output);
    };

    FileUtil.file_age = function(file, callback) {
      return FileUtil.file_mtime(file, function(err, mtime) {
        if (err != null) {
          return callback(err);
        } else if (mtime == null) {
          return callback(null, null);
        } else {
          return callback(null, Date.now() - mtime);
        }
      });
    };

    FileUtil.file_mtime = function(file, callback) {
      return fs.exists(file, function(exists) {
        if (!exists) {
          return callback(null, false);
        } else {
          return fs.stat(file, function(err, stats) {
            var ref1, ref2, ref3;
            if (err != null) {
              return callback(err);
            } else {
              return callback(null, (ref1 = (ref2 = stats.mtime) != null ? typeof ref2.getTime === "function" ? ref2.getTime() : void 0 : void 0) != null ? ref1 : (ref3 = stats.ctime) != null ? typeof ref3.getTime === "function" ? ref3.getTime() : void 0 : void 0);
            }
          });
        }
      });
    };

    FileUtil.file_age_sync = function(file, callback) {
      var mtime;
      mtime = FileUtil.file_mtime_sync(file);
      if (mtime) {
        return Date.now() - mtime;
      } else {
        return mtime;
      }
    };

    FileUtil.file_mtime_sync = function(file) {
      var ref1, ref2, ref3, stat;
      if (!fs.existsSync(file)) {
        return false;
      } else {
        stat = fs.statSync(file);
        return (ref1 = (ref2 = stat.mtime) != null ? typeof ref2.getTime === "function" ? ref2.getTime() : void 0 : void 0) != null ? ref1 : (ref3 = stat.ctime) != null ? typeof ref3.getTime === "function" ? ref3.getTime() : void 0 : void 0;
      }
    };

    FileUtil.replace_extension = function(filename, ext) {
      var new_filename;
      if ((ext != null) && !/^\./.test(ext)) {
        ext = "." + ext;
      }
      new_filename = FileUtil.strip_extension(filename);
      if (ext != null) {
        new_filename = "" + new_filename + ext;
      }
      return new_filename;
    };

    FileUtil.replace_ext = function(filename, ext) {
      return FileUtil.replace_extension(filename, ext);
    };

    FileUtil.strip_extension = function(filename) {
      var dir, ext, file;
      if (filename != null) {
        dir = path.dirname(filename);
        file = path.basename(filename);
        ext = path.extname(file);
        if ((ext != null) && ext.length > 0) {
          file = file.substring(0, file.length - ext.length);
        }
        return path.join(dir, file);
      } else {
        return filename;
      }
    };

    FileUtil.strip_ext = function(filename) {
      return FileUtil.strip_extension(filename);
    };

    FileUtil.get_extension = function(filename) {
      var ext, ref1;
      if (filename != null) {
        ext = (ref1 = Util.blank_to_null(path.extname(filename))) != null ? ref1 : filename;
        if (/^\./.test(ext)) {
          ext = ext.substring(1, ext.length);
        }
        return ext;
      } else {
        return null;
      }
    };

    FileUtil.get_ext = function(filename) {
      return FileUtil.get_extension(filename);
    };

    FileUtil._rank_mime = function(mime) {
      if (mime == null) {
        return 0;
      } else if (mime === "application/unknown") {
        return 10;
      } else if (mime === "application/octet-stream") {
        return 20;
      } else if (mime === "text/text" || mime === "image/image" || mime === "audio/audio" || mime === "video/video" || mime === "application/application") {
        return 30;
      } else if (mime === "text/plain") {
        return 40;
      } else if (mime === "text/html" || mime === "text/xml") {
        return 100;
      } else {
        return 99999;
      }
    };

    FileUtil._choose_mime = function(mime_a, mime_b) {
      var norm_a, norm_b, rank_a, rank_b;
      norm_a = FileUtil._normalize_mime(mime_a);
      norm_b = FileUtil._normalize_mime(mime_b);
      rank_a = FileUtil._rank_mime(norm_a);
      rank_b = FileUtil._rank_mime(norm_b);
      if (rank_a > rank_b) {
        return mime_a;
      } else if (rank_b > rank_a) {
        return mime_b;
      } else {
        rank_a = FileUtil._rank_mime(mime_a);
        rank_b = FileUtil._rank_mime(mime_b);
        if (rank_a >= rank_b) {
          return mime_a;
        } else {
          return mime_b;
        }
      }
    };

    FileUtil.get_mime = function(filename, callback) {
      return FileUtil.get_mime_via_magic(filename, function(err, by_magic) {
        var by_ext;
        by_ext = FileUtil.get_mime_for_ext(filename);
        return callback(err, FileUtil._choose_mime(by_magic, by_ext));
      });
    };

    FileUtil.get_mime_type = function(filename, callback) {
      return FileUtil.get_mime(filename, callback);
    };

    FileUtil.get_file_mime_type = function(filename, callback) {
      return FileUtil.get_mime(filename, callback);
    };

    FileUtil.get_mime_via_magic = function(filename, callback) {
      return magic.detectFile(filename, callback);
    };

    FileUtil.get_mime_type_via_magic = function(filename, callback) {
      return FileUtil.get_mime_via_magic(filename, callback);
    };

    FileUtil.get_file_mime_type_via_magic = function(filename, callback) {
      return FileUtil.get_mime_via_magic(filename, callback);
    };

    FileUtil.is_pdf = function(filename, callback) {
      return FileUtil.file_is_pdf(filename, callback);
    };

    FileUtil.file_is_pdf = function(filename, callback) {
      return FileUtil.file_is_mime(filename, /^application\/pdf/i, callback);
    };

    FileUtil.is_mime = function(filename, mime_pattern, callback) {
      return FileUtil.file_is_mime(filename, mime_pattern, callback);
    };

    FileUtil.file_is_mime = function(filename, mime_pattern, callback) {
      return FileUtil.get_mime(filename, function(err, mime) {
        if (err != null) {
          return callback(err);
        } else {
          if (typeof mime_pattern === 'string') {
            return callback(null, mime === mime_pattern);
          } else {
            return callback(null, mime_pattern.test(mime));
          }
        }
      });
    };

    FileUtil._normalize_ext = function(ext) {
      if (ext != null) {
        if (/^\./.test(ext)) {
          ext = ext.substring(1);
        }
        ext = ext != null ? ext.toLowerCase() : void 0;
      }
      return ext;
    };

    FileUtil._normalize_mime = function(mime) {
      var match;
      if (mime != null) {
        match = mime.match(/^\s*([^\/\s]+\/[^\s;\/]+)\s*(;.*)?$/);
        if ((match != null ? match[1] : void 0) != null) {
          mime = match[1];
        }
        mime = mime != null ? mime.toLowerCase() : void 0;
      }
      return mime;
    };

    FileUtil.get_mime_for_ext = function(ext) {
      var ref1;
      ext = FileUtil.get_extension(ext);
      return (ref1 = FileUtil.get_ext_to_mime_map()[ext]) != null ? ref1 : FileUtil.get_ext_to_mime_map()[FileUtil._normalize_ext(ext)];
    };

    FileUtil.get_mime_for_extension = function(ext) {
      return FileUtil.get_mime_for_ext(ext);
    };

    FileUtil.get_ext_for_mime = function(mime) {
      var ref1;
      return (ref1 = FileUtil.get_mime_to_ext_map()[mime]) != null ? ref1 : FileUtil.get_mime_to_ext_map()[FileUtil._normalize_mime(mime)];
    };

    FileUtil.get_extension_for_mime = function(mime) {
      return FileUtil.get_ext_for_mime(mime);
    };

    FileUtil._ext_to_mime_map = null;

    FileUtil._EXT_TO_MIME_MAP = null;

    FileUtil._mime_to_ext_map = null;

    FileUtil._MIME_TO_EXT_MAP = null;

    FileUtil.get_ext_to_mime_map = function() {
      if (FileUtil._ext_to_mime_map == null) {
        FileUtil._ext_to_mime_map = FileUtil._get_EXT_TO_MIME_MAP();
      }
      return FileUtil._ext_to_mime_map;
    };

    FileUtil.get_extension_to_mime_map = function() {
      return FileUtil.get_ext_to_mime_map();
    };

    FileUtil.get_mime_to_ext_map = function() {
      if (FileUtil._mime_to_ext_map == null) {
        FileUtil._mime_to_ext_map = FileUtil._get_MIME_TO_EXT_MAP();
      }
      return FileUtil._mime_to_ext_map;
    };

    FileUtil.get_mime_to_extension_map = function() {
      return FileUtil.get_mime_to_ext_map();
    };

    FileUtil.set_ext_to_mime_map = function(mapping) {
      return FileUtil._ext_to_mime_map = mapping;
    };

    FileUtil.set_extension_to_mime_map = function(mapping) {
      return FileUtil.set_ext_to_mime_map(mapping);
    };

    FileUtil.set_mime_to_ext_map = function(mapping) {
      return FileUtil._mime_to_ext_map = mapping;
    };

    FileUtil.set_mime_to_extension_map = function() {
      return FileUtil.set_mime_to_ext_map(mapping);
    };

    FileUtil.add_to_mime_to_ext_map = function() {
      var mappings, pair;
      mappings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((mappings != null ? mappings.length : void 0) === 2 && ((typeof mappings[0]) === 'string') && ((typeof mappings[1]) === 'string')) {
        pair = {};
        pair[mappings[0]] = mappings[1];
        mappings = [pair];
      }
      return FileUtil._mime_to_ext_map = Util.merge.apply(Util, [FileUtil.get_mime_to_ext_map()].concat(slice.call(mappings)));
    };

    FileUtil.add_to_mime_to_extension_map = function() {
      var mappings;
      mappings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return FileUtil.add_mime_to_ext_map.apply(FileUtil, mappings);
    };

    FileUtil.add_to_ext_to_mime_map = function() {
      var mappings, pair;
      mappings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((mappings != null ? mappings.length : void 0) === 2 && ((typeof mappings[0]) === 'string') && ((typeof mappings[1]) === 'string')) {
        pair = {};
        pair[mappings[0]] = mappings[1];
        mappings = [pair];
      }
      return FileUtil._ext_to_mime_map = Util.merge.apply(Util, [FileUtil.get_ext_to_mime_map()].concat(slice.call(mappings)));
    };

    FileUtil.add_to_extension_to_mime_map = function() {
      var mappings;
      mappings = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return FileUtil.add_ext_to_mime_map.apply(FileUtil, mappings);
    };

    FileUtil._get_EXT_TO_MIME_MAP = function() {
      if (FileUtil._EXT_TO_MIME_MAP == null) {
        FileUtil._EXT_TO_MIME_MAP = JSON.parse(fs.readFileSync(path.join(DATA, "ext-to-mime.json")));
      }
      return FileUtil._EXT_TO_MIME_MAP;
    };

    FileUtil._get_MIME_TO_EXT_MAP = function() {
      if (FileUtil._MIME_TO_EXT_MAP == null) {
        FileUtil._MIME_TO_EXT_MAP = JSON.parse(fs.readFileSync(path.join(DATA, "mime-to-ext.json")));
      }
      return FileUtil._MIME_TO_EXT_MAP;
    };

    return FileUtil;

  })();

  exports.FileUtil = FileUtil;

}).call(this);

//# sourceMappingURL=file-util.js.map
