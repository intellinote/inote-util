// Generated by CoffeeScript 1.12.6
(function() {
  var AsyncUtil, DEFAULT_RESOLVE_HOSTNAME_MAX_PARALLEL_TESTS, DEFAULT_RESOLVE_HOSTNAME_TIMEOUT, HOME_DIR, LIB_COV, LIB_DIR, NetUtil, URL, Util, cluster, dns, fs, http, https, net, path, shelljs;

  fs = require('fs');

  path = require('path');

  HOME_DIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOME_DIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOME_DIR, 'lib');

  Util = require(path.join(LIB_DIR, 'util')).Util;

  AsyncUtil = require(path.join(LIB_DIR, 'async-util')).AsyncUtil;

  cluster = require('cluster');

  dns = require('dns');

  http = require('http');

  https = require('https');

  net = require('net');

  shelljs = require('shelljs');

  URL = require('url');

  DEFAULT_RESOLVE_HOSTNAME_TIMEOUT = 333;

  DEFAULT_RESOLVE_HOSTNAME_MAX_PARALLEL_TESTS = 16;

  NetUtil = (function() {
    function NetUtil() {}

    NetUtil.normalize_url = function(url) {
      var ref, ref1;
      return (ref = (ref1 = URL.parse(url)) != null ? ref1.href : void 0) != null ? ref : url;
    };

    NetUtil.get_pid = function() {
      var ref, ref1, ref2, ref3;
      if (NetUtil.random_pid == null) {
        NetUtil.random_pid = Math.round(Math.random() * 32768);
      }
      return (ref = (ref1 = cluster != null ? (ref2 = cluster.worker) != null ? (ref3 = ref2.process) != null ? ref3.pid : void 0 : void 0 : void 0) != null ? ref1 : typeof process !== "undefined" && process !== null ? process.pid : void 0) != null ? ref : NetUtil.random_pid;
    };

    NetUtil.random_port = function(min, range) {
      if (min == null) {
        min = 2000;
      }
      if (range == null) {
        range = 1000;
      }
      return min + Math.round(Math.random() * range);
    };

    NetUtil.get_unused_port = function() {
      var base_port, command, err, output, port, ref;
      base_port = 2000 + (NetUtil.get_pid() % 10000);
      command = "for port in $(seq " + base_port + " 65000); do echo -ne \"\\035\" | telnet 127.0.0.1 $port > /dev/null 2>&1; [ $? -eq 1 ] && echo \"$port\" && break; done";
      port = null;
      try {
        output = shelljs.exec(command, {
          silent: true
        });
        port = Util.to_int(output != null ? (ref = output.output) != null ? ref.trim() : void 0 : void 0);
      } catch (error) {
        err = error;
        console.error("ERROR in NetUtil.get_unused_port: ", err);
      }
      if (port == null) {
        port = NetUtil.random_port();
      }
      return port;
    };

    NetUtil.is_port_in_use = function(port, callback) {
      var server;
      server = net.createServer();
      server.once("error", function(err) {
        if ((err != null) && err.code === 'EADDRINUSE') {
          return callback(null, true);
        } else {
          return callback(err);
        }
      });
      server.once("listening", function() {
        server.once("close", function() {
          return callback(null, false);
        });
        return server.close();
      });
      return server.listen(port);
    };

    NetUtil.resolve_hostname = function(host, options, callback) {
      var max_parallel_tests, port, protocol, ref, ref1, ref2, ref3, ref4, ref5, ref6, reject_unauthorized, timeout;
      if (typeof options === 'function' && (callback == null)) {
        callback = options;
        options = null;
      }
      if (options == null) {
        options = {};
      }
      protocol = (ref = options.protocol) != null ? ref : "https:";
      protocol = protocol.toLowerCase();
      if (!/:$/.test(protocol)) {
        protocol = protocol + ":";
      }
      port = (ref1 = Util.to_int(options.port)) != null ? ref1 : protocol === 'http:' ? 80 : 443;
      path = (ref2 = options.path) != null ? ref2 : "/";
      timeout = (ref3 = Util.to_int(options.timeout)) != null ? ref3 : DEFAULT_RESOLVE_HOSTNAME_TIMEOUT;
      max_parallel_tests = (ref4 = Util.to_int(options.max_parallel_tests)) != null ? ref4 : DEFAULT_RESOLVE_HOSTNAME_MAX_PARALLEL_TESTS;
      reject_unauthorized = Util.truthy_string((ref5 = (ref6 = options.reject_unauthorized) != null ? ref6 : options.rejectUnauthorized) != null ? ref5 : true);
      return dns.resolve(host, function(err, ip_addresses) {
        var called_back, test_ip_action;
        if (err != null) {
          return callback(err);
        } else {
          called_back = false;
          test_ip_action = function(ip_address, index, list, next) {
            var client;
            if (called_back) {
              return next();
            } else {
              client = protocol === 'http:' ? http : https;
              return client.get({
                protocol: protocol,
                host: ip_address,
                port: port,
                path: path,
                headers: {
                  Host: host
                },
                timeout: timeout,
                rejectUnauthorized: reject_unauthorized
              }, function(res) {
                var ref7;
                if (((res != null ? res.statusCode : void 0) != null) && ((res != null ? (ref7 = res.socket) != null ? ref7.remoteAddress : void 0 : void 0) != null)) {
                  if (!called_back) {
                    callback(null, res.socket.remoteAddress);
                    return called_back = true;
                  }
                }
              }).on('error', next);
            }
          };
          return AsyncUtil.throttled_fork_for_each_async(max_parallel_tests, ip_addresses, test_ip_action, function() {
            if (!called_back) {
              return callback(new Error("Unable to find live server for host '" + host + "'."));
            }
          });
        }
      });
    };

    return NetUtil;

  })();

  exports.NetUtil = NetUtil;

}).call(this);
