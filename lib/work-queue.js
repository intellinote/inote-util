// Generated by CoffeeScript 1.12.6
(function() {
  var DEFAULT_FUZZ_FACTOR, DEFAULT_INTERVAL, DEFAULT_MAX_WORKERS, DEFAULT_PRIORITY, EventEmitter, HOMEDIR, LIB_COV, LIB_DIR, PriorityQueue, Util, WorkQueue, fs, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  Util = require(path.join(LIB_DIR, 'util')).Util;

  PriorityQueue = require('priorityqueuejs');

  EventEmitter = require('events').EventEmitter;

  DEFAULT_PRIORITY = 5;

  DEFAULT_INTERVAL = 200;

  DEFAULT_FUZZ_FACTOR = 1 / 10;

  DEFAULT_MAX_WORKERS = 1;

  WorkQueue = (function(superClass) {
    extend(WorkQueue, superClass);

    function WorkQueue(options) {
      this.stop_working = bind(this.stop_working, this);
      this.start_working = bind(this.start_working, this);
      this.dequeue_task = bind(this.dequeue_task, this);
      this.enqueue_task = bind(this.enqueue_task, this);
      this.active_task_count = bind(this.active_task_count, this);
      this.pending_task_count = bind(this.pending_task_count, this);
      var ref, ref1, ref2, ref3;
      if (options == null) {
        options = {};
      }
      this.default_priority = (ref = options.priority) != null ? ref : DEFAULT_PRIORITY;
      this.work_interval = (ref1 = options.interval) != null ? ref1 : DEFAULT_INTERVAL;
      this.fuzz_factor = (ref2 = options.fuzz) != null ? ref2 : DEFAULT_FUZZ_FACTOR;
      this.max_workers = (ref3 = options.workers) != null ? ref3 : DEFAULT_MAX_WORKERS;
    }

    WorkQueue.prototype.pending_task_count = function() {
      var ref, ref1;
      return (ref = (ref1 = this.queue) != null ? ref1.size() : void 0) != null ? ref : 0;
    };

    WorkQueue.prototype.active_task_count = function() {
      var ref;
      return (ref = this.tasks_running) != null ? ref : 0;
    };

    WorkQueue.prototype.enqueue_task = function(method, args, priority, callback) {
      var task;
      if (typeof args === 'function' && (priority == null) && (callback == null)) {
        callback = args;
        priority = null;
        args = null;
      } else if (typeof priority === 'function' && (callback == null)) {
        callback = priority;
        priority = null;
      }
      if (method == null) {
        method = (function(cb) {
          return cb();
        });
      }
      if (args == null) {
        args = [];
      }
      if (priority == null) {
        priority = this.default_priority;
      }
      if (callback == null) {
        callback = (function() {
          return void 0;
        });
      }
      if (!Array.isArray(args)) {
        args = [args];
      }
      task = {
        priority: priority,
        method: method,
        args: args,
        callback: callback
      };
      if (this.queue == null) {
        this.queue = new PriorityQueue(function(a, b) {
          return a.priority - b.priority;
        });
      }
      this.queue.enq(task);
      this.emit("task-enqueued", this, task);
      return this.pending_task_count();
    };

    WorkQueue.prototype.dequeue_task = function() {
      var err, ref, task;
      if ((this.queue == null) || this.queue.isEmpty()) {

      } else if (this.tasks_running >= this.max_workers) {
        return this.emit("busy", this);
      } else {
        if (this.tasks_running == null) {
          this.tasks_running = 0;
        }
        this.tasks_running += 1;
        task = (ref = this.queue) != null ? ref.deq() : void 0;
        this.emit("task-dequeued", this, task);
        try {
          return task.method.apply(task, slice.call(task.args).concat([(function(_this) {
            return function() {
              var result;
              result = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              if (_this.tasks_running == null) {
                _this.tasks_running = 1;
              }
              _this.tasks_running -= 1;
              task.callback.apply(task, result);
              return process.nextTick(function() {
                return _this.emit("task-completed", _this, task, result);
              });
            };
          })(this)]));
        } catch (error) {
          err = error;
          if (this.tasks_running == null) {
            this.tasks_running = 1;
          }
          this.tasks_running -= 1;
          if (EventEmitter.listenerCount(this, 'error') > 0) {
            return this.emit("error", this, task, err);
          } else {
            throw err;
          }
        }
      }
    };

    WorkQueue.prototype.start_working = function(options) {
      var delay, fuzz, fuzz_factor, ref, ref1;
      if (this.worker != null) {
        this.stop_work();
      }
      if (options == null) {
        options = {};
      }
      delay = (ref = Util.to_int(options.interval)) != null ? ref : this.work_interval;
      fuzz_factor = parseFloat((ref1 = options.fuzz) != null ? ref1 : this.fuzz_factor);
      if (isNaN(fuzz) || (typeof fuzz === "undefined" || fuzz === null)) {
        fuzz_factor = this.fuzz_factor;
      }
      if (fuzz_factor && fuzz_factor > 0) {
        fuzz = (Math.random() * (2 * delay * fuzz_factor)) - (delay * fuzz_factor);
        delay = Math.round(delay + fuzz);
        if (delay <= 0) {
          delay = this.work_interval;
        }
      }
      process.nextTick((function(_this) {
        return function() {
          _this.worker = setInterval(_this.dequeue_task);
          return _this.emit("work-beginning", _this);
        };
      })(this));
      return this.pending_task_count();
    };

    WorkQueue.prototype.stop_working = function() {
      if (this.worker) {
        clearInterval(this.worker);
      }
      this.worker = null;
      process.nextTick((function(_this) {
        return function() {
          return _this.emit("work-ending", _this);
        };
      })(this));
      return this.pending_task_count();
    };

    return WorkQueue;

  })(EventEmitter);

  exports.WorkQueue = WorkQueue;

}).call(this);

//# sourceMappingURL=work-queue.js.map
