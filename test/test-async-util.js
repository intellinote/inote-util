// Generated by CoffeeScript 1.12.6
(function() {
  var AsyncUtil, HOMEDIR, LIB_COV, LIB_DIR, Sequencer, fs, path, should;

  should = require('should');

  fs = require('fs');

  path = require('path');

  HOMEDIR = path.join(__dirname, '..');

  LIB_COV = path.join(HOMEDIR, 'lib-cov');

  LIB_DIR = fs.existsSync(LIB_COV) ? LIB_COV : path.join(HOMEDIR, 'lib');

  AsyncUtil = require(path.join(LIB_DIR, 'async-util')).AsyncUtil;

  Sequencer = require(path.join(LIB_DIR, 'async-util')).Sequencer;

  describe('AsyncUtil', function() {
    it("for_each_async can execute an async for-each loop", (function(_this) {
      return function(done) {
        var action, count, j, numbers, results1, total;
        numbers = (function() {
          results1 = [];
          for (j = 1; j <= 100; j++){ results1.push(j); }
          return results1;
        }).apply(this);
        total = 0;
        count = 0;
        action = function(number, index, list, next) {
          count++;
          total += number;
          index.should.equal(number - 1);
          index.should.equal(count - 1);
          list.length.should.equal(numbers.length);
          return next();
        };
        return AsyncUtil.for_each_async(numbers, action, function() {
          total.should.equal(5050);
          count.should.equal(numbers.length);
          return done();
        });
      };
    })(this));
    it("procedure can execute a series of async steps", (function(_this) {
      return function(done) {
        var P, step_one, step_one_executed, step_three, step_three_executed, step_two, step_two_executed;
        step_one_executed = false;
        step_two_executed = false;
        step_three_executed = false;
        step_one = function(next) {
          step_one_executed.should.equal(false);
          step_two_executed.should.equal(false);
          step_three_executed.should.equal(false);
          step_one_executed = true;
          return next("foo", "bar");
        };
        step_two = function(foo, bar, next) {
          foo.should.equal("foo");
          bar.should.equal("bar");
          step_one_executed.should.equal(true);
          step_two_executed.should.equal(false);
          step_three_executed.should.equal(false);
          step_two_executed = true;
          return next();
        };
        step_three = function() {
          step_one_executed.should.equal(true);
          step_two_executed.should.equal(true);
          step_three_executed.should.equal(false);
          step_three_executed = true;
          return done();
        };
        P = AsyncUtil.procedure();
        P.first(step_one);
        P.then(step_two);
        return P["finally"](step_three);
      };
    })(this));
    it("wait_until can wait for a condition to be true", (function(_this) {
      return function(done) {
        var predicate, start_time, target, times_run;
        start_time = Date.now();
        target = 300;
        times_run = 0;
        predicate = function() {
          times_run++;
          return (Date.now() - start_time) >= target;
        };
        return AsyncUtil.wait_until(predicate, 10, function(err, complete) {
          var initial_times_run;
          initial_times_run = times_run;
          should.not.exist(err);
          complete.should.equal(true);
          times_run.should.be.above(1);
          return AsyncUtil.wait(target, function() {
            times_run.should.equal(initial_times_run);
            return done();
          });
        });
      };
    })(this));
    it("wait_for is an alias for wait_until and treats negative delay (and null delay) as default delay", (function(_this) {
      return function(done) {
        var predicate, start_time, target, times_run;
        start_time = Date.now();
        target = 300;
        times_run = 0;
        predicate = function() {
          times_run++;
          return (Date.now() - start_time) >= target;
        };
        return AsyncUtil.wait_for(predicate, -10, function(err, complete) {
          var initial_times_run;
          initial_times_run = times_run;
          should.not.exist(err);
          complete.should.equal(true);
          times_run.should.be.above(1);
          return AsyncUtil.wait(target, function() {
            times_run.should.equal(initial_times_run);
            return done();
          });
        });
      };
    })(this));
    it("wait_until passes error to callback when encountered", (function(_this) {
      return function(done) {
        var predicate, start_time, target, times_run;
        start_time = Date.now();
        target = 300;
        times_run = 0;
        predicate = function() {
          times_run++;
          if ((Date.now() - start_time) >= target) {
            throw new Error("Mock Error");
          } else {
            return false;
          }
        };
        return AsyncUtil.wait_until(predicate, function(err, complete) {
          should.exist(err);
          should.not.exist(complete);
          times_run.should.be.above(1);
          return done();
        });
      };
    })(this));
    it("fork runs methods in parallel", (function(_this) {
      return function(done) {
        var args, method_one, method_one_finished, method_one_started, method_one_val, method_two, method_two_finished, method_two_started, method_two_val_one, method_two_val_two, methods, when_done;
        method_one_started = false;
        method_one_val = null;
        method_one_finished = false;
        method_two_started = false;
        method_two_finished = false;
        method_two_val_one = null;
        method_two_val_two = null;
        method_one = function(val, next) {
          method_one_started = true;
          method_one_val = val;
          AsyncUtil.wait(10, function() {
            method_two_started.should.be.ok;
            return method_two_finished.should.not.be.ok;
          });
          return AsyncUtil.wait(400, function() {
            method_two_started.should.be.ok;
            method_two_finished.should.be.ok;
            method_one_finished = true;
            return next("ABC", val);
          });
        };
        method_two = function(val1, val2, next) {
          method_two_started = true;
          method_two_val_one = val1;
          method_two_val_two = val2;
          AsyncUtil.wait(10, function() {
            method_one_started.should.be.ok;
            return method_one_finished.should.not.be.ok;
          });
          return AsyncUtil.wait(200, function() {
            method_one_started.should.be.ok;
            method_one_finished.should.not.be.ok;
            method_two_finished = true;
            return next("XYZ", val1, val2);
          });
        };
        when_done = function(results) {
          results.length.should.equal(2);
          results[0].length.should.equal(2);
          results[0][0].should.equal("ABC");
          results[0][1].should.equal("abc");
          results[1].length.should.equal(3);
          results[1][0].should.equal("XYZ");
          results[1][1].should.equal("x");
          results[1][2].should.equal("yz");
          method_one_finished.should.be.ok;
          method_two_finished.should.be.ok;
          return done();
        };
        methods = [method_one, method_two];
        args = [["abc"], ["x", "yz"]];
        return AsyncUtil.fork(methods, args, when_done);
      };
    })(this));
    it("fork_for_each_async works", (function(_this) {
      return function(done) {
        var action, args, ran, when_done;
        args = [0, 1, 2, 3, 4];
        ran = args.map(function() {
          return false;
        });
        action = function(elt, index, list, next) {
          elt.should.equal(index);
          ran[elt].should.not.be.ok;
          ran[elt] = true;
          return next(elt);
        };
        when_done = function(results) {
          var elt, i, j, k, len, len1;
          for (j = 0, len = args.length; j < len; j++) {
            i = args[j];
            results[i][0].should.equal(i);
          }
          for (k = 0, len1 = ran.length; k < len1; k++) {
            elt = ran[k];
            elt.should.be.ok;
          }
          return done();
        };
        return AsyncUtil.fork_for_each_async(args, action, when_done);
      };
    })(this));
    return it("throttled fork limits the number of methods running in parallel", (function(_this) {
      return function(done) {
        var args, method, methods, num_true, order_done, ran, running;
        args = [0, 1, 2, 3, 4];
        order_done = [];
        running = args.map(function() {
          return false;
        });
        ran = args.map(function() {
          return false;
        });
        num_true = function(list) {
          var count, elt, j, len;
          count = 0;
          for (j = 0, len = list.length; j < len; j++) {
            elt = list[j];
            if (elt) {
              count++;
            }
          }
          return count;
        };
        method = function(step, next) {
          num_true(running).should.be.below(4);
          running[step] = true;
          return AsyncUtil.wait(((1 + args.length) * 100) - (step * 100), function() {
            num_true(running).should.be.below(4);
            running[step] = false;
            order_done.push(step);
            ran[step] = true;
            return next(step);
          });
        };
        args = [0, 1, 2, 3, 4];
        methods = args.map(function() {
          return method;
        });
        return AsyncUtil.throttled_fork(3, methods, args, function(results) {
          var elt, i, j, k, len, len1, ref, step;
          ref = [2, 1, 0];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            step = ref[i];
            order_done[i].should.equal(step);
          }
          for (k = 0, len1 = args.length; k < len1; k++) {
            i = args[k];
            results[i][0].should.equal(i);
          }
          for (elt in running) {
            elt.should.not.be.ok;
          }
          for (elt in ran) {
            elt.should.be.ok;
          }
          return done();
        });
      };
    })(this));
  });

}).call(this);
